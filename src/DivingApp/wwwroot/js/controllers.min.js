///<reference path="../../typings/angularjs/angular.d.ts" /> 
var Diving;
(function (Diving) {
    var Services;
    (function (Services) {
        var DataService = (function () {
            function DataService($http) {
                this.http = $http;
            }
            DataService.prototype.GetGeoPoints = function (email, callback) {
                this.http.get('/api/dives/getdiveswithcoordinates/' + email, {
                    cache: false
                }).success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    callback(error);
                });
            };
            DataService.prototype.GetPhotosIds = function (email, diveId, minPhoto, callback) {
                this.http.get('/api/dives/getuserphotoidsbydiveids/' + email + '/' + diveId + '/' + minPhoto).success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    callback(error);
                });
            };
            DataService.prototype.GetPhoto = function (email, photoId, callback) {
                this.http.get('/GetPhoto/' + email + '/' + photoId).success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    callback(error);
                });
            };
            DataService.prototype.GetAuthorizedUserDives = function (callback) {
                var req = {
                    method: 'GET',
                    url: '/api/dives/getuserdives/' + Date.now(),
                    cache: false,
                    headers: { 'Cache-Control': 'no-cache' }
                };
                this.http(req).success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    callback(error);
                });
            };
            DataService.prototype.GetAuthorizedUserDiveById = function (diveId, callback) {
                this.http.get('/api/dives/getuserdivebyid/' + diveId + '/' + Date.now(), {
                    cache: false
                }).success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    callback(error);
                });
            };
            DataService.prototype.GetDiveDictionaries = function (callback) {
                this.http.get('/api/dives/getdivedictionaries').success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    callback(error);
                });
            };
            DataService.prototype.SaveDive = function (dive, callback, errorHandler) {
                var req = {
                    method: 'POST',
                    url: '/api/dives/saveDive',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded'
                    },
                    data: $.param(dive)
                };
                this.http(req).success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    errorHandler(error);
                });
            };
            DataService.prototype.DeleteDive = function (diveId, callback) {
                this.http.delete('/api/dives/deleteDive/' + diveId).success(function (data, status) {
                    callback(data);
                }).error(function (error) {
                    callback(error);
                });
            };
            return DataService;
        })();
        Services.DataService = DataService;
    })(Services = Diving.Services || (Diving.Services = {}));
})(Diving || (Diving = {}));

var Diving;
(function (Diving) {
    var Controllers;
    (function (Controllers) {
        var rootController = (function () {
            function rootController($scope) {
                this.$scope = $scope;
                this.scope = $scope;
            }
            rootController.prototype.DiveCreateNew = function () {
                this.scope.DiveChild.CreateNewDive();
            };
            rootController.prototype.DiveShowDives = function () {
                this.scope.DiveChild.CancelCreateNewDive();
            };
            rootController.prototype.HasDives = function () {
                this.scope.DiveChild.dives && this.scope.DiveChild.dives.length > 0;
            };
            return rootController;
        })();
        Controllers.rootController = rootController;
    })(Controllers = Diving.Controllers || (Diving.Controllers = {}));
})(Diving || (Diving = {}));

///<reference path="../../typings/angularjs/angular.d.ts" /> 
var Diving;
(function (Diving) {
    var Controllers;
    (function (Controllers) {
        var loginController = (function () {
            function loginController($scope) {
                this.$scope = $scope;
                this.showLogin = true;
                this.showSearch = false;
                this.showSearchResults = false;
                this.showSearchNotFound = false;
            }
            loginController.prototype.showTab = function (tabIndex) {
                if (tabIndex == 1) {
                    this.showLogin = true;
                    this.showSearchResults = this.showSearch = false;
                }
                if (tabIndex == 2) {
                    this.showSearch = true;
                    this.showLogin = this.showSearchResults = false;
                }
                if (tabIndex == 3) {
                    this.showSearchResults = true;
                    this.showLogin = this.showSearch = false;
                }
            };
            loginController.prototype.searchDivers = function () {
                this.showSearchNotFound = false;
                $.ajax({
                    type: "GET",
                    url: "api/users/getusersbyname/" + this.searchCriteria,
                    cache: false,
                    context: this,
                    success: function (data) {
                        if (data.length > 0) {
                            this.showSearch = false;
                            this.showSearchResults = true;
                            this.searchResults = data;
                        }
                        else {
                            this.showSearchNotFound = true;
                        }
                        this.$scope.$apply();
                    }
                });
            };
            loginController.prototype.openPasp = function (id) {
                location.href = 'passport/external/' + id;
            };
            return loginController;
        })();
        Controllers.loginController = loginController;
    })(Controllers = Diving.Controllers || (Diving.Controllers = {}));
})(Diving || (Diving = {}));

///<reference path="../../typings/angularjs/angular.d.ts" /> 
///<reference path="../../typings/google.maps.d.ts" /> 
var Diving;
(function (Diving) {
    var Controllers;
    (function (Controllers) {
        var paspController = (function () {
            function paspController($scope, PaspService) {
                this.paspService = PaspService;
                this.selectedDiveId = -1;
                this.selectedPhotoIndex = -1;
                this.showDives = true;
                this.showMaps = false;
                this.showPhoto = false;
                this.showGeoDiveInfo = false;
                this.map = undefined;
                this.scope = $scope;
            }
            paspController.prototype.init = function (userEmail) {
                this.currentUserEmail = userEmail;
            };
            paspController.prototype.hidePhoto = function () {
                this.showPhoto = false;
            };
            paspController.prototype.showTab = function (tabIndex) {
                if (tabIndex == 1) {
                    this.showDives = true;
                    this.showMaps = false;
                }
                if (tabIndex == 2) {
                    this.showDives = false;
                    this.showMaps = true;
                    var that = this;
                    setTimeout(function () {
                        this.options = {
                            zoom: 3,
                            center: new google.maps.LatLng(1, 1),
                            mapTypeId: google.maps.MapTypeId.ROADMAP
                        };
                        if (!that.map) {
                            that.map = new google.maps.Map(document.getElementById('map'), this.options);
                            that.map.addListener('zoom_changed', function () {
                                that.showGeoDiveInfo = false;
                                that.scope.$apply();
                            });
                            that.map.addListener('click', function () {
                                that.showGeoDiveInfo = false;
                                that.scope.$apply();
                            });
                        }
                        that.paspService.GetGeoPoints(that.currentUserEmail, function (data) {
                            that.markers = [];
                            var marker;
                            for (var i = 0; i < data.length; i++) {
                                if (data[i].CoordinateX && data[i].CoordinateY) {
                                    var clickHandler = function () {
                                        var currentDive = data[i];
                                        var diveId = data[i].DiveId;
                                        marker = new google.maps.Marker({
                                            map: that.map,
                                            draggable: false,
                                            title: data[i].Location + ": " + data[i].DiveComment,
                                            position: new google.maps.LatLng(data[i].CoordinateX, data[i].CoordinateY)
                                        });
                                        marker.data = data[i];
                                        marker.addListener('click', function (e) {
                                            that.selectedGeoDive = this.data;
                                            var overlay = new google.maps.OverlayView();
                                            overlay.draw = function () { };
                                            overlay.setMap(that.map);
                                            var proj = overlay.getProjection();
                                            var pos = this.getPosition();
                                            var p = proj.fromLatLngToContainerPixel(pos);
                                            $('#geoDiveDetails').css({
                                                top: p.y + $('#geoDiveDetails').parent().position().top - $('#geoDiveDetails').height(),
                                                left: p.x + 40,
                                                position: 'absolute'
                                            });
                                            that.showGeoDiveInfo = true;
                                            that.scope.$apply();
                                        });
                                        that.markers.push(marker);
                                    };
                                    clickHandler();
                                }
                            }
                            var marker = new MarkerClusterer(that.map, that.markers);
                        });
                    }, 100);
                }
            };
            paspController.prototype.getPhotos = function (diveId) {
                this.showGeoDiveInfo = false;
                this.resetPhoto();
                this.selectedDiveId = diveId;
                var that = this;
                this.paspService.GetPhotosIds(this.currentUserEmail, this.selectedDiveId, 0, function (data) {
                    that.photos = data;
                    if (that.photos.length > 0) {
                        that.selectedPhotoIndex = 0;
                        that.changeCurrentPhotoIndex(that.selectedPhotoIndex);
                    }
                });
            };
            paspController.prototype.showNext = function () {
                if (this.selectedPhotoIndex < this.photos.length - 1)
                    this.selectedPhotoIndex++;
                else
                    this.selectedPhotoIndex = 0;
                this.changeCurrentPhotoIndex(this.selectedPhotoIndex);
            };
            paspController.prototype.openPasp = function (id) {
                location.href = 'Pasp/PaspShow?login=' + id;
            };
            paspController.prototype.changeCurrentPhotoIndex = function (index) {
                if (index == -1)
                    this.hidePhoto();
                else {
                    var that = this;
                    this.paspService.GetPhoto(this.currentUserEmail, this.photos[this.selectedPhotoIndex], function (data) {
                        that.selectedPhotoInfo = new photoDetailes();
                        that.selectedPhotoInfo.photoId = that.photos[that.selectedPhotoIndex];
                        that.selectedPhotoInfo.photoDate = "Photo date: " + moment(data.Date).format('DD/MM/YYYY');
                        that.selectedPhotoInfo.photoInfo = data.Comment;
                        that.showPhoto = true;
                        that.scope.$apply();
                    });
                }
            };
            paspController.prototype.resetPhoto = function () {
                this.selectedPhotoIndex = -1;
                this.changeCurrentPhotoIndex(this.selectedPhotoIndex);
            };
            return paspController;
        })();
        Controllers.paspController = paspController;
        var photoDetailes = (function () {
            function photoDetailes() {
            }
            return photoDetailes;
        })();
        Controllers.photoDetailes = photoDetailes;
        var selectedGeoDetailes = (function () {
            function selectedGeoDetailes() {
            }
            return selectedGeoDetailes;
        })();
        Controllers.selectedGeoDetailes = selectedGeoDetailes;
    })(Controllers = Diving.Controllers || (Diving.Controllers = {}));
})(Diving || (Diving = {}));
var MarkerClusterer;
var moment;

///<reference path="../../typings/angularjs/angular.d.ts" /> 
///<reference path="../../typings/google.maps.d.ts" /> 
var Diving;
(function (Diving) {
    var Controllers;
    (function (Controllers) {
        var diveController = (function () {
            function diveController($scope, dataService) {
                var scope = $scope.$parent;
                scope.DiveChild = this;
                this.dataService = dataService;
                this.selectedPhotoIndex = -1;
                this.selectedDiveId = -1;
                this.showLoadingTab = true;
                this.showDivesList = true;
                this.showDivesTab = false;
                this.showMapsTab = false;
                this.showPhotosTab = false;
                this.showPhoto = false;
                this.showPhotoDelete = false;
                this.showSearchingGeoStatus = false;
                this.showUpdateMessage = false;
                this.map = undefined;
                this.scope = $scope;
                var that = this;
                dataService.GetDiveDictionaries(function (data) {
                    that.countries = data.Countries;
                    that.suits = data.Suits;
                    that.weights = data.Weights;
                    that.tanks = data.Tanks;
                    that.time = data.Time;
                    that.refreshDives(that, -1, false);
                });
            }
            diveController.prototype.Init = function (userEmail) {
                this.currentUserEmail = userEmail;
            };
            diveController.prototype.ShowSelectedDiveTab = function (tabIndex) {
                if (tabIndex == 0)
                    this.showLoadingTab = true;
                else {
                    this.showLoadingTab = false;
                    if (tabIndex == 1) {
                        this.showDivesTab = true;
                        this.showMapsTab = false;
                        this.showPhotosTab = false;
                    }
                    if (tabIndex == 2) {
                        this.showUpdateMessage = false;
                        this.showDivesTab = false;
                        this.showMapsTab = true;
                        this.showPhotosTab = false;
                        var that = this;
                        setTimeout(function () {
                            var lat = that.selectedDive && that.selectedDive.Latitude ? that.selectedDive.Latitude : 1;
                            var lan = that.selectedDive && that.selectedDive.Longitude ? that.selectedDive.Longitude : 1;
                            this.options = {
                                zoom: that.selectedDive && that.selectedDive.Latitude && that.selectedDive.Longitude ? 6 : 2,
                                center: new google.maps.LatLng(lat, lan),
                                mapTypeId: google.maps.MapTypeId.ROADMAP
                            };
                            that.map = new google.maps.Map(document.getElementById('map'), this.options);
                            that.map.addListener('zoom_changed', function () {
                                that.scope.$apply();
                            });
                            that.map.addListener('click', function () {
                                that.scope.$apply();
                            });
                            if (that.selectedDive && that.selectedDive.Latitude && that.selectedDive.Longitude) {
                                that.marker = new google.maps.Marker({
                                    map: that.map,
                                    draggable: true,
                                    title: that.selectedDive.Location,
                                    position: new google.maps.LatLng(that.selectedDive.Latitude, that.selectedDive.Longitude)
                                });
                                google.maps.event.addListener(that.marker, 'dragend', function () {
                                    that.selectedDive.Latitude = that.marker.getPosition().lat().toFixed(6).replace(".", ",");
                                    that.selectedDive.Longitude = that.marker.getPosition().lng().toFixed(6).replace(".", ",");
                                });
                            }
                        });
                    }
                    if (tabIndex == 3) {
                        this.showUpdateMessage = false;
                        this.showDivesTab = false;
                        this.showMapsTab = false;
                        this.showPhotosTab = true;
                    }
                }
            };
            diveController.prototype.SearchForLocation = function () {
                if (this.marker)
                    this.marker.setMap(null);
                this.showSearchingGeoStatus = true;
                var geocoder = new google.maps.Geocoder();
                var that = this;
                geocoder.geocode({ 'address': this.location }, function (results, status) {
                    if (status == google.maps.GeocoderStatus.OK) {
                        var myOptions = {
                            zoom: 8,
                            center: results[0].geometry.location,
                            mapTypeId: google.maps.MapTypeId.ROADMAP
                        };
                        that.map = new google.maps.Map($("#map")[0], myOptions);
                        that.marker = new google.maps.Marker({
                            map: that.map,
                            draggable: true,
                            position: results[0].geometry.location
                        });
                        that.selectedDive.Latitude = results[0].geometry.location.lat().toFixed(6);
                        that.selectedDive.Longitude = results[0].geometry.location.lng().toFixed(6);
                        var lat = results[0].geometry.location.lat().toFixed(6);
                        var lgn = results[0].geometry.location.lng().toFixed(6);
                        google.maps.event.addListener(that.marker, 'dragend', function () {
                            that.selectedDive.Latitude = that.marker.getPosition().lat().toFixed(6);
                            that.selectedDive.Longitude = that.marker.getPosition().lng().toFixed(6);
                        });
                    }
                    else {
                        alert("Failed to make request to GEO service: " + status);
                    }
                    that.showSearchingGeoStatus = false;
                    that.scope.$apply();
                });
            };
            diveController.prototype.GetDive = function (diveId) {
                this.showUpdateMessage = false;
                this.HidePhotoDelete();
                this.ShowSelectedDiveTab(0);
                this.selectedDiveId = diveId;
                var that = this;
                setTimeout(function () {
                    that.dataService.GetAuthorizedUserDiveById(diveId, function (data) {
                        that.location = "";
                        that.resetPhoto();
                        that.selectedDive = data;
                        that.ShowSelectedDiveTab(1);
                        that.showDivesList = true;
                    });
                }, 250);
            };
            diveController.prototype.GetPhoto = function (id) {
                this.selectedPhotoIndex = this.selectedDive.Photos.map(function (e) { return e.PhotoId; }).indexOf(id);
                this.changeCurrentPhotoIndex(this.selectedPhotoIndex);
            };
            diveController.prototype.ShowNext = function () {
                if (this.selectedPhotoIndex < this.selectedDive.Photos.length - 1)
                    this.selectedPhotoIndex++;
                else
                    this.selectedPhotoIndex = 0;
                this.changeCurrentPhotoIndex(this.selectedPhotoIndex);
            };
            diveController.prototype.HidePhoto = function () {
                this.showPhoto = false;
            };
            diveController.prototype.ShowPhotoDelete = function () {
                this.showPhotoDelete = true;
            };
            diveController.prototype.HidePhotoDelete = function () {
                this.showPhotoDelete = false;
            };
            diveController.prototype.ShowDiveDelete = function (diveId) {
                this.dives[this.dives.map(function (e) { return e.DiveID; }).indexOf(diveId)].ShowDelete = true;
            };
            diveController.prototype.HideDiveDelete = function (diveId) {
                this.dives[this.dives.map(function (e) { return e.DiveID; }).indexOf(diveId)].ShowDelete = false;
            };
            diveController.prototype.CreateNewDive = function () {
                this.showDivesList = false;
                this.selectedDive = new Object;
                this.selectedDive.WeightIsOk = this.weights[0].Value;
                this.selectedDive.SuitType = this.suits[0].Value;
                this.selectedDive.Tank = this.tanks[0].Value;
                this.selectedDive.DiveTime = this.time[0].Value;
                this.selectedDive.CountryId = 804;
                this.selectedDive.DiveDate = this.selectedDive.DiveDateString = moment(Date.now()).format('DD/MM/YYYY');
                if (this.marker)
                    this.marker.setMap(null);
                this.ShowSelectedDiveTab(1);
                this.showUpdateMessage = false;
            };
            diveController.prototype.SaveDive = function () {
                this.errors = null;
                this.ShowSelectedDiveTab(0);
                this.selectedDive.DiveDate = this.selectedDive.DiveDateString;
                var selectedId = this.selectedDive && this.selectedDive.DiveID ? this.selectedDive.DiveID : -1;
                var that = this;
                this.dataService.SaveDive(this.selectedDive, function (data) {
                    that.refreshDives(that, selectedId, (selectedId > 0));
                }, function (error) {
                    that.errors = error;
                    that.ShowSelectedDiveTab(1);
                });
            };
            diveController.prototype.DeleteDive = function (diveId) {
                var that = this;
                this.dataService.DeleteDive(diveId, function (data) {
                    that.refreshDives(that, -1, false);
                    that.ShowSelectedDiveTab(1);
                }, function (error) {
                    that.errors = error;
                    that.ShowSelectedDiveTab(1);
                });
            };
            diveController.prototype.CancelCreateNewDive = function () {
                if (this.dives.length > 0)
                    this.GetDive(this.dives[0].DiveID);
                this.showDivesList = true;
            };
            diveController.prototype.refreshDives = function (context, diveId, showUpdated) {
                context.dataService.GetAuthorizedUserDives(function (data) {
                    context.dives = data;
                    if (data.length > 0) {
                        context.GetDive(diveId == -1 ? data[0].DiveID : diveId);
                    }
                    else {
                        context.CreateNewDive();
                    }
                    context.showUpdateMessage = showUpdated;
                });
            };
            diveController.prototype.changeCurrentPhotoIndex = function (index) {
                this.HidePhotoDelete();
                if (index == -1)
                    this.HidePhoto();
                else {
                    var that = this;
                    this.dataService.GetPhoto(this.currentUserEmail, this.selectedDive.Photos[this.selectedPhotoIndex], function (data) {
                        that.selectedPhotoInfo = new Controllers.photoDetailes();
                        that.selectedPhotoInfo.photoId = that.selectedDive.Photos[that.selectedPhotoIndex];
                        that.selectedPhotoInfo.photoDate = moment(data.Date).format('DD/MM/YYYY');
                        that.selectedPhotoInfo.photoInfo = data.Comment;
                        that.showPhoto = true;
                    });
                }
            };
            diveController.prototype.resetPhoto = function () {
                this.selectedPhotoIndex = -1;
                this.changeCurrentPhotoIndex(this.selectedPhotoIndex);
            };
            return diveController;
        })();
        Controllers.diveController = diveController;
    })(Controllers = Diving.Controllers || (Diving.Controllers = {}));
})(Diving || (Diving = {}));
var MarkerClusterer;
var moment;


function FileDestroyController($scope, $http, fileUpload) {
    var file = $scope.file,
        state;

    if ($scope.$parent && $scope.$parent.$parent && $scope.$parent.$parent.$parent.name) {
        $scope.fieldname = $scope.$parent.$parent.$parent.name;
    }

    if (!fileUpload.fieldData[$scope.name]) {
        fileUpload.fieldData[$scope.name] = [];
    }

    $scope.filequeue = fileUpload.fieldData;

    if (file.url) {
        file.$state = function () {
            return state;
        };
        file.$destroy = function () {
            state = 'pending';
            return $http({
                url: file.deleteUrl,
                method: file.deleteType
            }).then(
                function () {
                    state = 'resolved';
                    fileUpload.removeFieldData($scope.fieldname, file.result._id);
                    $scope.clear(file);
                },
                function () {
                    state = 'rejected';
                    fileUpload.removeFieldData($scope.fieldname, file.result._id);
                    $scope.clear(file);
                }
                );


        };
    } else if (!file.$cancel && !file._index) {
        file.$cancel = function () {
            $scope.clear(file);
        };
    }
};

function fileUploadDirective() {
    return {
        restrict: 'E',
        templateUrl: './templates/fileform.html',
        scope: {
            allowed: '@',
            url: '@',
            autoUpload: '@',
            sizeLimit: '@',
            ngModel: '=',
            name: '@'
        },
        controller: ['$scope', '$element', 'fileUpload', function (
            $scope, $element, fileUpload) {
            $scope.$on('fileuploaddone', function (e, data) {
                fileUpload.addFieldData($scope.name, data._response.result.files[0].result);
            });

            $scope.options = {
                url: $scope.url,
                dropZone: $element,
                maxFileSize: $scope.sizeLimit,
                autoUpload: $scope.autoUpload
            };
            $scope.loadingFiles = false;

            if (!$scope.queue) {
                $scope.queue = [];
            }

            var generateFileObject = function generateFileObjects(objects) {
                angular.forEach(objects, function (value, key) {
                    var fileObject = {
                        name: value.filename,
                        size: value.length,
                        url: value.url,
                        thumbnailUrl: value.url,
                        deleteUrl: value.url,
                        deleteType: 'DELETE',
                        result: value
                    };

                    if (fileObject.url && fileObject.url.charAt(0) !== '/') {
                        fileObject.url = '/' + fileObject.url;
                    }

                    if (fileObject.deleteUrl && fileObject.deleteUrl.charAt(0) !== '/') {
                        fileObject.deleteUrl = '/' + fileObject.deleteUrl;
                    }

                    if (fileObject.thumbnailUrl && fileObject.thumbnailUrl.charAt(0) !== '/') {
                        fileObject.thumbnailUrl = '/' + fileObject.thumbnailUrl;
                    }

                    $scope.queue[key] = fileObject;
                });
            };
            fileUpload.registerField($scope.name);
            $scope.filequeue = fileUpload.fieldData[$scope.name];

            $scope.$watchCollection('filequeue', function (newval) {
                generateFileObject(newval);
            });
        }]
    };
};
/*
 * jQuery File Upload AngularJS Plugin
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */

/* jshint nomen:false */
/* global define, angular */

(function (factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // Register as an anonymous AMD module:
        define([
            'jquery',
            'angular',
            './jquery.fileupload-image',
            './jquery.fileupload-audio',
            './jquery.fileupload-video',
            './jquery.fileupload-validate'
        ], factory);
    } else {
        factory();
    }
}(function () {
    'use strict';

    angular.module('blueimp.fileupload', [])

        // The fileUpload service provides configuration options
        // for the fileUpload directive and default handlers for
        // File Upload events:
        .provider('fileUpload', function () {
            var scopeEvalAsync = function (expression) {
                    var scope = angular.element(this)
                            .fileupload('option', 'scope');
                    // Schedule a new $digest cycle if not already inside of one
                    // and evaluate the given expression:
                    scope.$evalAsync(expression);
                },
                addFileMethods = function (scope, data) {
                    var files = data.files,
                        file = files[0];
                    angular.forEach(files, function (file, index) {
                        file._index = index;
                        file.$state = function () {
                            return data.state();
                        };
                        file.$processing = function () {
                            return data.processing();
                        };
                        file.$progress = function () {
                            return data.progress();
                        };
                        file.$response = function () {
                            return data.response();
                        };
                    });
                    file.$submit = function () {
                        if (!file.error) {
                            return data.submit();
                        }
                    };
                    file.$cancel = function () {
                        return data.abort();
                    };
                },
                $config;
            $config = this.defaults = {
                handleResponse: function (e, data) {
                    var files = data.result && data.result.files;
                    if (files) {
                        data.scope.replace(data.files, files);
                    } else if (data.errorThrown ||
                            data.textStatus === 'error') {
                        data.files[0].error = data.errorThrown ||
                            data.textStatus;
                    }
                },
                add: function (e, data) {
                    if (e.isDefaultPrevented()) {
                        return false;
                    }
                    var scope = data.scope,
                        filesCopy = [];
                    angular.forEach(data.files, function (file) {
                        filesCopy.push(file);
                    });
                    scope.$parent.$applyAsync(function () {
                        addFileMethods(scope, data);
                        var method = scope.option('prependFiles') ?
                                'unshift' : 'push';
                        Array.prototype[method].apply(scope.queue, data.files);
                    });
                    data.process(function () {
                        return scope.process(data);
                    }).always(function () {
                        scope.$parent.$applyAsync(function () {
                            addFileMethods(scope, data);
                            scope.replace(filesCopy, data.files);
                        });
                    }).then(function () {
                        if ((scope.option('autoUpload') ||
                                data.autoUpload) &&
                                data.autoUpload !== false) {
                            data.submit();
                        }
                    });
                },
                done: function (e, data) {
                    if (e.isDefaultPrevented()) {
                        return false;
                    }
                    var that = this;
                    data.scope.$apply(function () {
                        data.handleResponse.call(that, e, data);
                    });
                },
                fail: function (e, data) {
                    if (e.isDefaultPrevented()) {
                        return false;
                    }
                    var that = this,
                        scope = data.scope;
                    if (data.errorThrown === 'abort') {
                        scope.clear(data.files);
                        return;
                    }
                    scope.$apply(function () {
                        data.handleResponse.call(that, e, data);
                    });
                },
                stop: scopeEvalAsync,
                processstart: scopeEvalAsync,
                processstop: scopeEvalAsync,
                getNumberOfFiles: function () {
                    var scope = this.scope;
                    return scope.queue.length - scope.processing();
                },
                dataType: 'json',
                autoUpload: false
            };
            this.$get = [
                function () {
                    return {
                        defaults: $config
                    };
                }
            ];
        })

        // Format byte numbers to readable presentations:
        .provider('formatFileSizeFilter', function () {
            var $config = {
                // Byte units following the IEC format
                // http://en.wikipedia.org/wiki/Kilobyte
                units: [
                    {size: 1000000000, suffix: ' GB'},
                    {size: 1000000, suffix: ' MB'},
                    {size: 1000, suffix: ' KB'}
                ]
            };
            this.defaults = $config;
            this.$get = function () {
                return function (bytes) {
                    if (!angular.isNumber(bytes)) {
                        return '';
                    }
                    var unit = true,
                        i = 0,
                        prefix,
                        suffix;
                    while (unit) {
                        unit = $config.units[i];
                        prefix = unit.prefix || '';
                        suffix = unit.suffix || '';
                        if (i === $config.units.length - 1 || bytes >= unit.size) {
                            return prefix + (bytes / unit.size).toFixed(2) + suffix;
                        }
                        i += 1;
                    }
                };
            };
        })

        // The FileUploadController initializes the fileupload widget and
        // provides scope methods to control the File Upload functionality:
        .controller('FileUploadController', [
            '$scope', '$element', '$attrs', '$window', 'fileUpload',
            function ($scope, $element, $attrs, $window, fileUpload) {
                var uploadMethods = {
                    progress: function () {
                        return $element.fileupload('progress');
                    },
                    active: function () {
                        return $element.fileupload('active');
                    },
                    option: function (option, data) {
                        if (arguments.length === 1) {
                            return $element.fileupload('option', option);
                        }
                        $element.fileupload('option', option, data);
                    },
                    add: function (data) {
                        return $element.fileupload('add', data);
                    },
                    send: function (data) {
                        return $element.fileupload('send', data);
                    },
                    process: function (data) {
                        return $element.fileupload('process', data);
                    },
                    processing: function (data) {
                        return $element.fileupload('processing', data);
                    }
                };
                $scope.disabled = !$window.jQuery.support.fileInput;
                $scope.queue = $scope.queue || [];
                $scope.clear = function (files) {
                    var queue = this.queue,
                        i = queue.length,
                        file = files,
                        length = 1;
                    if (angular.isArray(files)) {
                        file = files[0];
                        length = files.length;
                    }
                    while (i) {
                        i -= 1;
                        if (queue[i] === file) {
                            return queue.splice(i, length);
                        }
                    }
                };
                $scope.replace = function (oldFiles, newFiles) {
                    var queue = this.queue,
                        file = oldFiles[0],
                        i,
                        j;
                    for (i = 0; i < queue.length; i += 1) {
                        if (queue[i] === file) {
                            for (j = 0; j < newFiles.length; j += 1) {
                                queue[i + j] = newFiles[j];
                            }
                            return;
                        }
                    }
                };
                $scope.applyOnQueue = function (method) {
                    var list = this.queue.slice(0),
                        i,
                        file;
                    for (i = 0; i < list.length; i += 1) {
                        file = list[i];
                        if (file[method]) {
                            file[method]();
                        }
                    }
                };
                $scope.submit = function () {
                    this.applyOnQueue('$submit');
                };
                $scope.cancel = function () {
                    this.applyOnQueue('$cancel');
                };
                // Add upload methods to the scope:
                angular.extend($scope, uploadMethods);
                // The fileupload widget will initialize with
                // the options provided via "data-"-parameters,
                // as well as those given via options object:
                $element.fileupload(angular.extend(
                    {scope: $scope},
                    fileUpload.defaults
                )).on('fileuploadadd', function (e, data) {
                    data.scope = $scope;
                }).on('fileuploadfail', function (e, data) {
                    if (data.errorThrown === 'abort') {
                        return;
                    }
                    if (data.dataType &&
                            data.dataType.indexOf('json') === data.dataType.length - 4) {
                        try {
                            data.result = angular.fromJson(data.jqXHR.responseText);
                        } catch (ignore) {}
                    }
                }).on([
                    'fileuploadadd',
                    'fileuploadsubmit',
                    'fileuploadsend',
                    'fileuploaddone',
                    'fileuploadfail',
                    'fileuploadalways',
                    'fileuploadprogress',
                    'fileuploadprogressall',
                    'fileuploadstart',
                    'fileuploadstop',
                    'fileuploadchange',
                    'fileuploadpaste',
                    'fileuploaddrop',
                    'fileuploaddragover',
                    'fileuploadchunksend',
                    'fileuploadchunkdone',
                    'fileuploadchunkfail',
                    'fileuploadchunkalways',
                    'fileuploadprocessstart',
                    'fileuploadprocess',
                    'fileuploadprocessdone',
                    'fileuploadprocessfail',
                    'fileuploadprocessalways',
                    'fileuploadprocessstop'
                ].join(' '), function (e, data) {
                    $scope.$parent.$applyAsync(function () {
                        if ($scope.$emit(e.type, data).defaultPrevented) {
                            e.preventDefault();
                        }
                    });
                }).on('remove', function () {
                    // Remove upload methods from the scope,
                    // when the widget is removed:
                    var method;
                    for (method in uploadMethods) {
                        if (uploadMethods.hasOwnProperty(method)) {
                            delete $scope[method];
                        }
                    }
                });
                // Observe option changes:
                $scope.$watch(
                    $attrs.fileUpload,
                    function (newOptions) {
                        if (newOptions) {
                            $element.fileupload('option', newOptions);
                        }
                    }
                );
            }
        ])

        // Provide File Upload progress feedback:
        .controller('FileUploadProgressController', [
            '$scope', '$attrs', '$parse',
            function ($scope, $attrs, $parse) {
                var fn = $parse($attrs.fileUploadProgress),
                    update = function () {
                        var progress = fn($scope);
                        if (!progress || !progress.total) {
                            return;
                        }
                        $scope.num = Math.floor(
                            progress.loaded / progress.total * 100
                        );
                    };
                update();
                $scope.$watch(
                    $attrs.fileUploadProgress + '.loaded',
                    function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            update();
                        }
                    }
                );
            }
        ])

        // Display File Upload previews:
        .controller('FileUploadPreviewController', [
            '$scope', '$element', '$attrs',
            function ($scope, $element, $attrs) {
                $scope.$watch(
                    $attrs.fileUploadPreview + '.preview',
                    function (preview) {
                        $element.empty();
                        if (preview) {
                            $element.append(preview);
                        }
                    }
                );
            }
        ])

        .directive('fileUpload', function () {
            return {
                controller: 'FileUploadController',
                scope: true
            };
        })

        .directive('fileUploadProgress', function () {
            return {
                controller: 'FileUploadProgressController',
                scope: true
            };
        })

        .directive('fileUploadPreview', function () {
            return {
                controller: 'FileUploadPreviewController'
            };
        })

        // Enhance the HTML5 download attribute to
        // allow drag&drop of files to the desktop:
        .directive('download', function () {
            return function (scope, elm) {
                elm.on('dragstart', function (e) {
                    try {
                        e.originalEvent.dataTransfer.setData(
                            'DownloadURL',
                            [
                                'application/octet-stream',
                                elm.prop('download'),
                                elm.prop('href')
                            ].join(':')
                        );
                    } catch (ignore) {}
                });
            };
        });

}));

var appModule = angular.module("diving-app", ['blueimp.fileupload', 'ngAnimate']);
var FileDestroyController;
var fileUploadDirective;
appModule.controller('rootController', ['$scope', function ($scope) { return new Diving.Controllers.rootController($scope); }]);
appModule.controller("loginController", ['$scope', function ($scope) { return new Diving.Controllers.loginController($scope); }]);
appModule.controller('paspController', ['$scope', "DataService", Diving.Controllers.paspController]);
appModule.controller('diveController', ['$scope', "DataService", Diving.Controllers.diveController]);
appModule.controller('FileDestroyController', ['$scope', '$http', 'fileUpload', FileDestroyController]);
appModule.directive('ngUploadForm', fileUploadDirective);
appModule.factory("DataService", ["$http", function ($http) { return new Diving.Services.DataService($http); }]);
